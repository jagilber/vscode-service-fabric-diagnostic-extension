{
  "id": "error-handling-patterns",
  "title": "Error Handling Patterns and Best Practices",
  "body": "**Follow these error handling patterns** for consistent user experience:\n\n## Error Hierarchy (models/Errors.ts)\n```\nServiceFabricError (base)\n├─ ClusterConnectionError\n│  ├─ CertificateNotFoundError\n│  ├─ EndpointUnreachableError\n│  └─ AuthenticationError\n├─ ApiError\n│  ├─ ApiTimeoutError\n│  ├─ ApiResponseError (4xx, 5xx)\n│  └─ ApiParseError\n└─ ConfigurationError\n   ├─ InvalidEndpointError\n   └─ MissingSettingsError\n```\n\n## Error Context Enrichment\nAll errors MUST include:\n```typescript\nthrow new ClusterConnectionError('Failed to connect', {\n    clusterId: 'prod-cluster',\n    endpoint: 'https://cluster.azure.com:19080',\n    cause: originalError,      // Wrap original error\n    timestamp: Date.now()\n});\n```\n\n## Error Recovery Strategies\n\n### 1. Retry with Backoff (Transient Errors)\n```typescript\nawait retryPolicy.execute(async () => {\n    return await restClient.getClusterHealth(clusterId);\n});\n```\n- **When**: Network timeouts, 503 Service Unavailable\n- **Pattern**: Exponential backoff (1s → 2s → 4s)\n\n### 2. Fallback to Cache\n```typescript\ntry {\n    const health = await api.getClusterHealth(clusterId);\n    cache.set(`health:${clusterId}`, health);\n    return health;\n} catch (error) {\n    const cached = cache.get(`health:${clusterId}`);\n    if (cached) {\n        SfUtility.outputLog('⚠️ API failed, using cached data');\n        return cached;\n    }\n    throw error;\n}\n```\n- **When**: API temporarily unavailable but cached data exists\n\n### 3. User-Friendly Messages\n```typescript\nvscode.window.showErrorMessage(\n    `Cannot connect to cluster \"${clusterName}\". Check endpoint and certificate.`,\n    'Open Settings', 'Retry'\n).then(selection => {\n    if (selection === 'Open Settings') {\n        vscode.commands.executeCommand('workbench.action.openSettings', 'serviceFabric');\n    }\n});\n```\n- **Pattern**: Actionable messages with next steps\n- **Avoid**: Technical jargon (\"ECONNREFUSED\"), raw stack traces\n\n### 4. Logging All Errors\n```typescript\nSfUtility.outputLog(`❌ Error: ${error.message}`, error);\nconsole.error('Full stack:', error);\n```\n- Log to Output channel (user-visible): High-level message\n- Log to console (developer tools): Full stack + context\n\n## Specific Error Scenarios\n\n### Certificate Not Found\n```typescript\nif (error.code === 'ENOENT' || error.message.includes('certificate')) {\n    throw new CertificateNotFoundError(\n        `Certificate with thumbprint ${thumbprint} not found in Cert:\\\\CurrentUser\\\\My\\\\`,\n        { thumbprint, cause: error }\n    );\n}\n```\n\n### Endpoint Unreachable\n```typescript\nif (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\n    throw new EndpointUnreachableError(\n        `Cannot reach cluster at ${endpoint}. Check firewall and cluster status.`,\n        { endpoint, cause: error }\n    );\n}\n```\n\n### API Parse Errors\n```typescript\ntry {\n    return JSON.parse(responseBody);\n} catch (parseError) {\n    throw new ApiParseError(\n        'Invalid JSON response from Service Fabric API',\n        { endpoint, responseBody: responseBody.substring(0, 200), cause: parseError }\n    );\n}\n```\n\n## Security: Never Log Secrets\n- ❌ **NEVER** log: Certificate private keys, thumbprints in plain URLs, tokens\n- ✅ **OK to log**: Cluster IDs, endpoints (without auth), error codes\n\nSee ARCHITECTURE.md \"Error Handling\" section for complete hierarchy diagram.",
  "rationale": "Consistent error handling improves debugging, provides better user experience with actionable messages, and prevents sensitive data leakage in logs.",
  "priority": 6,
  "audience": "all",
  "requirement": "mandatory",
  "categories": ["error-handling", "security", "logging", "user-experience"],
  "primaryCategory": "error-handling",
  "contentType": "instruction",
  "schemaVersion": "3",
  "classification": "internal",
  "priorityTier": "P1",
  "owner": "jagilber",
  "semanticSummary": "Error handling patterns including error hierarchy, context enrichment, recovery strategies (retry, fallback, user messages, logging), specific scenarios, and security guidelines for sensitive data."
}
