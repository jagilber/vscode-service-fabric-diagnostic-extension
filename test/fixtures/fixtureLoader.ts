/**
 * Fixture Loader
 * 
 * Loads JSON fixture files generated by clusterGenerator.ts and provides
 * typed access to Service Fabric REST API response data for each cluster profile.
 * 
 * Usage:
 *   const profile = loadClusterProfile('1-node-dev');
 *   const nodes = profile.getResponse('/Nodes');
 *   const health = profile.getResponse('/$/GetClusterHealth');
 */

import * as fs from 'fs';
import * as path from 'path';

// ── Types ───────────────────────────────────────────────────────────

export interface ClusterProfile {
    /** Profile name (directory name) */
    name: string;
    /** Resolve a SF REST API path to the fixture data */
    getResponse(sfPath: string): any;
    /** Get all available fixture file names */
    getAvailableFixtures(): string[];
    /** Get raw JSON from a fixture file by name (e.g. 'nodes', 'applications') */
    getRawFixture(fixtureName: string): any;
}

/** Map from fixture file stem → SF REST API path patterns */
interface RouteMapping {
    fixtureFile: string;
    patterns: RegExp[];
    /** For parameterized routes, a function that resolves file path from URL params */
    resolver?: (sfPath: string, fixturesDir: string) => any | undefined;
}

// ── Constants ───────────────────────────────────────────────────────

const FIXTURES_BASE = path.join(__dirname, 'clusters');

/** Available cluster profiles */
export const AVAILABLE_PROFILES = [
    '1-node-dev',
    '3-node-mixed',
    '5-node-azure',
    'large-cluster',
    'empty-cluster',
] as const;

export type ProfileName = typeof AVAILABLE_PROFILES[number] | string;

// ── Route Mappings ──────────────────────────────────────────────────

/**
 * Maps SF REST API URL patterns to fixture files.
 * Order matters — first match wins. More specific patterns come first.
 */
function buildRouteMappings(profileDir: string): RouteMapping[] {
    return [
        // ── Cluster endpoints ──
        {
            fixtureFile: 'cluster-health.json',
            patterns: [/^\/\$\/GetClusterHealth$/],
        },
        {
            fixtureFile: 'cluster-version.json',
            patterns: [/^\/\$\/GetClusterVersion$/],
        },
        {
            fixtureFile: 'cluster-manifest.json',
            patterns: [/^\/\$\/GetClusterManifest$/],
        },
        {
            fixtureFile: 'cluster-load.json',
            patterns: [/^\/\$\/GetClusterLoad$/],
        },

        // ── Repair tasks ──
        {
            fixtureFile: 'repair-tasks.json',
            patterns: [/^\/\$\/GetRepairTaskList$/],
        },

        // ── Application types ──
        {
            fixtureFile: 'application-types.json',
            patterns: [/^\/ApplicationTypes$/],
        },

        // ── Application manifest (parameterized) ──
        {
            fixtureFile: '',
            patterns: [/^\/ApplicationTypes\/([^/]+)\/\$\/GetApplicationManifest/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/ApplicationTypes\/([^/]+)\/\$\/GetApplicationManifest/);
                if (!match) { return undefined; }
                const typeName = match[1];
                const manifestFile = path.join(fixturesDir, 'manifests', `app-${typeName}.xml`);
                if (fs.existsSync(manifestFile)) {
                    return { Manifest: fs.readFileSync(manifestFile, 'utf-8') };
                }
                return undefined;
            },
        },

        // ── Service manifest (parameterized) ──
        {
            fixtureFile: '',
            patterns: [/^\/ApplicationTypes\/([^/]+)\/\$\/GetServiceManifest/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/ApplicationTypes\/([^/]+)\/\$\/GetServiceManifest/);
                if (!match) { return undefined; }
                // Extract ServiceManifestName from query params
                const qsMatch = sfPath.match(/ServiceManifestName=([^&]+)/);
                const svcManifestName = qsMatch ? qsMatch[1] : match[1];
                const manifestFile = path.join(fixturesDir, 'manifests', `svc-${svcManifestName}.xml`);
                if (fs.existsSync(manifestFile)) {
                    return { Manifest: fs.readFileSync(manifestFile, 'utf-8') };
                }
                return undefined;
            },
        },

        // ── Service type info (parameterized) ──
        {
            fixtureFile: '',
            patterns: [/^\/ApplicationTypes\/([^/]+)\/\$\/GetServiceTypes/],
            resolver: (_sfPath: string, _fixturesDir: string) => {
                // Return an empty array — generator doesn't produce this file
                return [];
            },
        },

        // ── Replicas (parameterized by partition ID) ──
        {
            fixtureFile: '',
            patterns: [/^\/Partitions\/([^/]+)\/\$\/GetReplicas$/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/Partitions\/([^/]+)\/\$\/GetReplicas$/);
                if (!match) { return undefined; }
                const partitionId = match[1];
                const replicaFile = path.join(fixturesDir, 'replicas', `${partitionId}.json`);
                if (fs.existsSync(replicaFile)) {
                    return JSON.parse(fs.readFileSync(replicaFile, 'utf-8'));
                }
                return [];
            },
        },

        // ── Replica health ──
        {
            fixtureFile: '',
            patterns: [/^\/Partitions\/([^/]+)\/\$\/GetReplicas\/([^/]+)\/\$\/GetHealth$/],
            resolver: (_sfPath: string, _fixturesDir: string) => {
                return { AggregatedHealthState: 'Ok', HealthEvents: [], UnhealthyEvaluations: [] };
            },
        },

        // ── Partition health ──
        {
            fixtureFile: '',
            patterns: [/^\/Partitions\/([^/]+)\/\$\/GetHealth$/],
            resolver: (_sfPath: string, _fixturesDir: string) => {
                return { AggregatedHealthState: 'Ok', HealthEvents: [], UnhealthyEvaluations: [] };
            },
        },

        // ── Partitions (parameterized by service ID) ──
        {
            fixtureFile: '',
            patterns: [/^\/Services\/(.+?)\/\$\/GetPartitions$/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/Services\/(.+?)\/\$\/GetPartitions$/);
                if (!match) { return undefined; }
                // Service ID uses / separator (e.g., SampleApp/SampleService)
                // but fixture files use _ separator
                const serviceId = decodeURIComponent(match[1]);
                const safeId = serviceId.replace(/\//g, '_');
                const partFile = path.join(fixturesDir, 'partitions', `${safeId}.json`);
                if (fs.existsSync(partFile)) {
                    return JSON.parse(fs.readFileSync(partFile, 'utf-8'));
                }
                return [];
            },
        },

        // ── Service health ──
        {
            fixtureFile: '',
            patterns: [/^\/Services\/(.+?)\/\$\/GetHealth$/],
            resolver: (_sfPath: string, _fixturesDir: string) => {
                return { AggregatedHealthState: 'Ok', HealthEvents: [], UnhealthyEvaluations: [] };
            },
        },

        // ── Services for an application (parameterized) ──
        {
            fixtureFile: '',
            patterns: [/^\/Applications\/([^/]+)\/\$\/GetServices$/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/Applications\/([^/]+)\/\$\/GetServices$/);
                if (!match) { return undefined; }
                const appId = match[1];
                const svcFile = path.join(fixturesDir, 'services', `${appId}.json`);
                if (fs.existsSync(svcFile)) {
                    return JSON.parse(fs.readFileSync(svcFile, 'utf-8'));
                }
                return [];
            },
        },

        // ── Application health (parameterized) ──
        {
            fixtureFile: '',
            patterns: [/^\/Applications\/([^/]+)\/\$\/GetHealth$/],
            resolver: (_sfPath: string, _fixturesDir: string) => {
                return {
                    AggregatedHealthState: 'Ok',
                    ServiceHealthStates: [],
                    DeployedApplicationHealthStates: [],
                    HealthEvents: [],
                    UnhealthyEvaluations: [],
                };
            },
        },

        // ── Single application info ──
        {
            fixtureFile: '',
            patterns: [/^\/Applications\/([^/]+)$/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/Applications\/([^/]+)$/);
                if (!match) { return undefined; }
                const appId = match[1];
                const appsFile = path.join(fixturesDir, 'applications.json');
                if (fs.existsSync(appsFile)) {
                    const apps = JSON.parse(fs.readFileSync(appsFile, 'utf-8'));
                    return apps.find((a: any) => a.Id === appId) || undefined;
                }
                return undefined;
            },
        },

        // ── Applications list ──
        {
            fixtureFile: 'applications.json',
            patterns: [/^\/Applications$/],
        },

        // ── System services (fabric:/System) ──
        {
            fixtureFile: 'system-services.json',
            patterns: [/^\/Applications\/System\/\$\/GetServices$/],
        },

        // ── Node health ──
        {
            fixtureFile: '',
            patterns: [/^\/Nodes\/([^/]+)\/\$\/GetHealth$/],
            resolver: (_sfPath: string, _fixturesDir: string) => {
                return { AggregatedHealthState: 'Ok', HealthEvents: [], UnhealthyEvaluations: [] };
            },
        },

        // ── Deployed applications on a node ──
        {
            fixtureFile: '',
            patterns: [/^\/Nodes\/([^/]+)\/\$\/GetApplications$/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/Nodes\/([^/]+)\/\$\/GetApplications$/);
                if (!match) { return []; }
                // Return all applications — simplified; a real server would filter by node
                const appsFile = path.join(fixturesDir, 'applications.json');
                if (fs.existsSync(appsFile)) {
                    return JSON.parse(fs.readFileSync(appsFile, 'utf-8'));
                }
                return [];
            },
        },

        // ── Single node info ──
        {
            fixtureFile: '',
            patterns: [/^\/Nodes\/([^/]+)$/],
            resolver: (sfPath: string, fixturesDir: string) => {
                const match = sfPath.match(/^\/Nodes\/([^/]+)$/);
                if (!match) { return undefined; }
                const nodeName = match[1];
                const nodesFile = path.join(fixturesDir, 'nodes.json');
                if (fs.existsSync(nodesFile)) {
                    const nodes = JSON.parse(fs.readFileSync(nodesFile, 'utf-8'));
                    return nodes.find((n: any) => n.Name === nodeName) || undefined;
                }
                return undefined;
            },
        },

        // ── Nodes list ──
        {
            fixtureFile: 'nodes.json',
            patterns: [/^\/Nodes$/],
        },

        // ── Image store ──
        {
            fixtureFile: 'image-store.json',
            patterns: [/^\/ImageStore$/],
        },

        // ── EventStore (return empty arrays) ──
        {
            fixtureFile: '',
            patterns: [/^\/EventsStore\//],
            resolver: () => [],
        },
    ];
}

// ── Profile Cache ───────────────────────────────────────────────────

const profileCache = new Map<string, ClusterProfile>();

// ── Public API ──────────────────────────────────────────────────────

/**
 * Load a cluster profile from the fixtures directory.
 * Results are cached for the lifetime of the process.
 * 
 * @param profileName - One of AVAILABLE_PROFILES or a custom directory name
 * @returns ClusterProfile with getResponse() for SF REST API path resolution
 * @throws Error if profile directory doesn't exist
 */
export function loadClusterProfile(profileName: ProfileName): ClusterProfile {
    const cached = profileCache.get(profileName);
    if (cached) { return cached; }

    const profileDir = path.join(FIXTURES_BASE, profileName);
    if (!fs.existsSync(profileDir)) {
        throw new Error(`Fixture profile not found: ${profileDir}. Run 'npm run generate-fixtures' to create fixture data.`);
    }

    const routeMappings = buildRouteMappings(profileDir);

    // Pre-load all static fixture files
    const staticFixtures = new Map<string, any>();
    const files = fs.readdirSync(profileDir).filter(f => f.endsWith('.json'));
    for (const file of files) {
        const content = fs.readFileSync(path.join(profileDir, file), 'utf-8');
        staticFixtures.set(file, JSON.parse(content));
    }

    const profile: ClusterProfile = {
        name: profileName,

        getResponse(sfPath: string): any {
            // Strip query params for pattern matching but keep original for resolvers
            const pathOnly = sfPath.split('?')[0];

            for (const mapping of routeMappings) {
                for (const pattern of mapping.patterns) {
                    if (pattern.test(pathOnly)) {
                        // Use resolver for parameterized routes
                        if (mapping.resolver) {
                            return mapping.resolver(sfPath, profileDir);
                        }
                        // Use static fixture file
                        const data = staticFixtures.get(mapping.fixtureFile);
                        if (data !== undefined) {
                            return data;
                        }
                    }
                }
            }

            // No match found
            return undefined;
        },

        getAvailableFixtures(): string[] {
            return Array.from(staticFixtures.keys()).map(f => f.replace('.json', ''));
        },

        getRawFixture(fixtureName: string): any {
            const key = fixtureName.endsWith('.json') ? fixtureName : `${fixtureName}.json`;
            return staticFixtures.get(key);
        },
    };

    profileCache.set(profileName, profile);
    return profile;
}

/**
 * Clear the profile cache (useful in tests)
 */
export function clearProfileCache(): void {
    profileCache.clear();
}

/**
 * List all available profile names from the fixtures directory
 */
export function listAvailableProfiles(): string[] {
    if (!fs.existsSync(FIXTURES_BASE)) {
        return [];
    }
    return fs.readdirSync(FIXTURES_BASE).filter(entry => {
        const fullPath = path.join(FIXTURES_BASE, entry);
        return fs.statSync(fullPath).isDirectory();
    });
}
