/**
 * Mock Service Fabric REST API Server
 * 
 * A lightweight HTTP server using Node's built-in http module that serves
 * fixture data matching the Service Fabric REST API surface. Designed for
 * integration testing without requiring a live SF cluster.
 * 
 * Features:
 * - Serves fixture data generated by clusterGenerator.ts
 * - Matches 30+ SF REST API URL patterns from SfDirectRestClient
 * - Supports switching cluster profiles at runtime
 * - Error injection for testing error handling
 * - Request logging for debugging
 * - Zero external dependencies
 * 
 * Usage:
 *   const server = new MockSfApiServer('1-node-dev');
 *   const { port, baseUrl } = await server.start();
 *   // ... run tests against baseUrl ...
 *   await server.stop();
 */

import * as http from 'http';
import * as url from 'url';
import { loadClusterProfile, ClusterProfile, ProfileName, listAvailableProfiles } from '../fixtures/fixtureLoader';

// ── Types ───────────────────────────────────────────────────────────

export interface MockServerOptions {
    /** Port to listen on (0 = auto-assign) */
    port?: number;
    /** Enable request logging to console */
    verbose?: boolean;
    /** Artificial response delay in ms (simulates network latency) */
    delay?: number;
}

export interface MockServerInfo {
    /** Assigned port number */
    port: number;
    /** Full base URL (e.g. http://localhost:19080) */
    baseUrl: string;
    /** Stop the server */
    stop: () => Promise<void>;
}

export interface ErrorInjection {
    /** SF REST API path pattern (regex) to match */
    pattern: RegExp;
    /** HTTP status code to return */
    statusCode: number;
    /** Error body to return */
    body?: any;
    /** Number of times to trigger (undefined = unlimited) */
    count?: number;
}

export interface RequestLog {
    timestamp: Date;
    method: string;
    path: string;
    statusCode: number;
    durationMs: number;
}

// ── Mock Server ─────────────────────────────────────────────────────

export class MockSfApiServer {
    private server: http.Server | null = null;
    private profile: ClusterProfile;
    private options: Required<MockServerOptions>;
    private errorInjections: ErrorInjection[] = [];
    private requestLog: RequestLog[] = [];
    private _port: number = 0;

    constructor(profileName: ProfileName, options?: MockServerOptions) {
        this.profile = loadClusterProfile(profileName);
        this.options = {
            port: options?.port ?? 0,
            verbose: options?.verbose ?? false,
            delay: options?.delay ?? 0,
        };
    }

    /**
     * Start the mock server.
     * @returns Server info with port, baseUrl, and stop function
     */
    async start(port?: number): Promise<MockServerInfo> {
        const listenPort = port ?? this.options.port;

        return new Promise<MockServerInfo>((resolve, reject) => {
            this.server = http.createServer((req, res) => this.handleRequest(req, res));

            this.server.on('error', (err) => {
                reject(err);
            });

            this.server.listen(listenPort, '127.0.0.1', () => {
                const addr = this.server!.address();
                if (typeof addr === 'object' && addr !== null) {
                    this._port = addr.port;
                } else {
                    this._port = listenPort;
                }

                if (this.options.verbose) {
                    console.log(`[MockSfApiServer] Listening on http://127.0.0.1:${this._port} (profile: ${this.profile.name})`);
                }

                resolve({
                    port: this._port,
                    baseUrl: `http://127.0.0.1:${this._port}`,
                    stop: () => this.stop(),
                });
            });
        });
    }

    /**
     * Stop the mock server.
     */
    async stop(): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            if (!this.server) {
                resolve();
                return;
            }
            this.server.close((err) => {
                this.server = null;
                if (err) {
                    reject(err);
                } else {
                    if (this.options.verbose) {
                        console.log('[MockSfApiServer] Stopped');
                    }
                    resolve();
                }
            });
        });
    }

    /**
     * Switch the active cluster profile (hot-swap without restart).
     */
    switchProfile(profileName: ProfileName): void {
        this.profile = loadClusterProfile(profileName);
        if (this.options.verbose) {
            console.log(`[MockSfApiServer] Switched to profile: ${profileName}`);
        }
    }

    /**
     * Add an error injection rule.
     * Matched requests will return the specified error instead of fixture data.
     */
    injectError(injection: ErrorInjection): void {
        this.errorInjections.push(injection);
    }

    /**
     * Clear all error injection rules.
     */
    clearErrors(): void {
        this.errorInjections = [];
    }

    /**
     * Get the request log.
     */
    getRequestLog(): ReadonlyArray<RequestLog> {
        return this.requestLog;
    }

    /**
     * Clear the request log.
     */
    clearRequestLog(): void {
        this.requestLog = [];
    }

    /**
     * Get the current port.
     */
    get port(): number {
        return this._port;
    }

    // ── Request Handler ─────────────────────────────────────────────

    private async handleRequest(req: http.IncomingMessage, res: http.ServerResponse): Promise<void> {
        const startTime = Date.now();
        const parsedUrl = url.parse(req.url || '/', true);
        const sfPath = this.extractSfPath(parsedUrl.pathname || '/');
        const method = req.method || 'GET';

        if (this.options.verbose) {
            console.log(`[MockSfApiServer] ${method} ${sfPath}`);
        }

        // Apply artificial delay
        if (this.options.delay > 0) {
            await new Promise(r => setTimeout(r, this.options.delay));
        }

        // Check error injections
        const injection = this.checkErrorInjection(sfPath);
        if (injection) {
            this.sendResponse(res, injection.statusCode, injection.body || {
                Error: {
                    Code: 'FABRIC_E_MOCK_ERROR',
                    Message: `Injected error for ${sfPath}`,
                },
            });
            this.logRequest(method, sfPath, injection.statusCode, startTime);
            return;
        }

        // Handle special meta-endpoints
        if (sfPath === '/_mock/profiles') {
            this.sendResponse(res, 200, {
                current: this.profile.name,
                available: listAvailableProfiles(),
            });
            this.logRequest(method, sfPath, 200, startTime);
            return;
        }

        if (sfPath.startsWith('/_mock/switch/')) {
            const newProfile = sfPath.replace('/_mock/switch/', '');
            try {
                this.switchProfile(newProfile);
                this.sendResponse(res, 200, { switched: newProfile });
            } catch (err: any) {
                this.sendResponse(res, 400, { error: err.message });
            }
            this.logRequest(method, sfPath, 200, startTime);
            return;
        }

        if (sfPath === '/_mock/log') {
            this.sendResponse(res, 200, this.requestLog);
            this.logRequest(method, sfPath, 200, startTime);
            return;
        }

        // Route to fixture data
        const fullPath = parsedUrl.pathname || '/';
        // Include query params for resolver matching (e.g., ServiceManifestName)
        const queryString = parsedUrl.search || '';
        const responseData = this.profile.getResponse(sfPath + queryString);

        if (responseData !== undefined) {
            this.sendResponse(res, 200, responseData);
            this.logRequest(method, sfPath, 200, startTime);
        } else {
            this.sendResponse(res, 404, {
                Error: {
                    Code: 'FABRIC_E_DOES_NOT_EXIST',
                    Message: `No fixture data for path: ${sfPath}`,
                },
            });
            this.logRequest(method, sfPath, 404, startTime);
        }
    }

    /**
     * Extract the SF API path from the raw URL path.
     * Strips query parameters that get appended by makeRequest (api-version, timeout).
     */
    private extractSfPath(rawPath: string): string {
        // The raw path might still have percent-encoded chars
        return decodeURIComponent(rawPath);
    }

    /**
     * Check if any error injection matches the current path.
     */
    private checkErrorInjection(sfPath: string): ErrorInjection | null {
        for (let i = this.errorInjections.length - 1; i >= 0; i--) {
            const injection = this.errorInjections[i];
            if (injection.pattern.test(sfPath)) {
                if (injection.count !== undefined) {
                    injection.count--;
                    if (injection.count <= 0) {
                        this.errorInjections.splice(i, 1);
                    }
                }
                return injection;
            }
        }
        return null;
    }

    /**
     * Send a JSON response.
     */
    private sendResponse(res: http.ServerResponse, statusCode: number, body: any): void {
        const json = typeof body === 'string' ? body : JSON.stringify(body);
        res.writeHead(statusCode, {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(json),
            // Match SF cluster response headers
            'X-ServiceFabric': 'true',
        });
        res.end(json);
    }

    /**
     * Log a request.
     */
    private logRequest(method: string, path: string, statusCode: number, startTime: number): void {
        this.requestLog.push({
            timestamp: new Date(),
            method,
            path,
            statusCode,
            durationMs: Date.now() - startTime,
        });
    }
}

// ── CLI entry point ─────────────────────────────────────────────────

if (require.main === module) {
    const profileName = process.argv[2] || '5-node-azure';
    const port = parseInt(process.argv[3] || '19080', 10);

    const server = new MockSfApiServer(profileName as ProfileName, { verbose: true });
    server.start(port).then(({ baseUrl }) => {
        console.log(`\nMock SF API server running at ${baseUrl}`);
        console.log(`Profile: ${profileName}`);
        console.log(`\nEndpoints:`);
        console.log(`  GET ${baseUrl}/Nodes`);
        console.log(`  GET ${baseUrl}/$/GetClusterHealth`);
        console.log(`  GET ${baseUrl}/Applications`);
        console.log(`  GET ${baseUrl}/_mock/profiles`);
        console.log(`  GET ${baseUrl}/_mock/switch/{profile}`);
        console.log(`\nPress Ctrl+C to stop`);
    });
}
