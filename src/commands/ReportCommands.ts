/**
 * Report generation command handlers.
 *
 * Extracted from extension.ts (~1,200 lines) into a dedicated module.
 * Commands:
 *   - generateEventsReport
 *   - generateHealthReport
 *   - generateMetricsReport
 *   - generateCommandsReference
 *   - generateEssentialsReport
 *   - generateRepairTasksReport
 *   - exportSnapshot
 *
 * All commands use `registerCommandWithErrorHandling` for consistent error
 * handling and double-registration protection.
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { SfMgr } from '../sfMgr';
import { SfUtility, debugLevel } from '../sfUtility';
import { registerCommandWithErrorHandling } from '../utils/CommandUtils';

// ===========================================================================
// Public registration entry point
// ===========================================================================

export function registerReportCommands(
    context: vscode.ExtensionContext,
    sfMgr: SfMgr,
): void {

    // -----------------------------------------------------------------------
    // generateEventsReport
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.generateEventsReport',
        async (item: any) => {
            if (!item || item.itemType !== 'events') {
                SfUtility.showWarning('This command is only available for Events');
                return;
            }
            const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
            if (!clusterEndpoint) { return; }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating Events Report',
                cancellable: false,
            }, async (progress) => {
                progress.report({ increment: 10, message: 'Fetching cluster events...' });

                const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
                const endTime = new Date();
                const startTime = new Date();
                startTime.setDate(startTime.getDate() - 7);
                const events = await sfRest.getClusterEvents(startTime.toISOString(), endTime.toISOString());

                progress.report({ increment: 40, message: `Processing ${events.length} events...` });
                progress.report({ increment: 30, message: 'Generating markdown...' });

                let markdown = `# Service Fabric Cluster Events Report\n\n`;
                markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
                markdown += `**Generated:** ${new Date().toLocaleString()}  \n`;
                markdown += `**Period:** ${startTime.toLocaleDateString()} - ${endTime.toLocaleDateString()}  \n`;
                markdown += `**Total Events:** ${events.length}  \n\n---\n\n`;

                if (events.length === 0) {
                    markdown += `## No Events Found\n\nNo cluster events were found in the EventStore for the specified time period.\n`;
                } else {
                    const eventsByKind = groupBy(events, (e: any) => e.Kind || e.kind || 'Other');

                    markdown += `## Event Summary\n\n`;
                    markdown += `| Event Type | Count | Health üî¥üü°üü¢ |\n|------------|-------|-------------|\n`;
                    sortedEntries(eventsByKind).forEach(([kind, kindEvents]) => {
                        const counts = healthCounts(kindEvents);
                        markdown += `| ${kind} | ${kindEvents.length} | üî¥${counts.Error} üü°${counts.Warning} üü¢${counts.Ok} |\n`;
                    });
                    markdown += `\n`;

                    const totalCounts = healthCounts(events);
                    markdown += `**Overall Health Distribution:**  \n`;
                    markdown += `üî¥ Error: ${totalCounts.Error} | üü° Warning: ${totalCounts.Warning} | üü¢ Ok: ${totalCounts.Ok} | ‚ö™ Unknown: ${totalCounts.Unknown}\n\n---\n\n`;

                    markdown += `## Detailed Events\n\n`;
                    sortedEntries(eventsByKind).forEach(([kind, kindEvents]) => {
                        markdown += `### ${kind} (${kindEvents.length} events)\n\n`;
                        const sorted = [...kindEvents].sort((a: any, b: any) => {
                            const tA = new Date(a.TimeStamp || a.timeStamp || 0).getTime();
                            const tB = new Date(b.TimeStamp || b.timeStamp || 0).getTime();
                            return tB - tA;
                        });
                        sorted.forEach((event: any) => {
                            markdown += formatEventDetail(event);
                        });
                    });
                }
                markdown += `\n---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

                await writeAndOpenReport(context, clusterEndpoint, 'events-report', markdown, progress);
            });
        },
        'generate events report',
    );

    // -----------------------------------------------------------------------
    // generateHealthReport
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.generateHealthReport',
        async (item: any) => {
            const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
            if (!clusterEndpoint) { return; }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating Health Report',
                cancellable: false,
            }, async (progress) => {
                progress.report({ increment: 10, message: 'Fetching cluster health...' });
                const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
                const clusterHealth = await sfRest.getClusterHealth();

                progress.report({ increment: 20, message: 'Fetching nodes health...' });
                const nodes = await sfRest.getNodes();

                progress.report({ increment: 20, message: 'Fetching applications health...' });
                const applications = await sfRest.getApplications();

                progress.report({ increment: 30, message: 'Generating markdown...' });

                const clusterHealthState = clusterHealth.aggregatedHealthState || 'Unknown';
                let markdown = `# Service Fabric Cluster Health Report\n\n`;
                markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
                markdown += `**Generated:** ${new Date().toLocaleString()}  \n\n---\n\n`;
                markdown += `## Cluster Health: ${healthEmoji(clusterHealthState)} ${clusterHealthState}\n\n`;

                // Health statistics
                if (clusterHealth.healthStatistics?.healthStateCountList) {
                    markdown += `### Health Statistics\n\n| Category | Ok | Warning | Error |\n|----------|----|---------| ------|\n`;
                    clusterHealth.healthStatistics.healthStateCountList.forEach((stat: any) => {
                        markdown += `| ${stat.entityKind} | ${stat.okCount || 0} | ${stat.warningCount || 0} | ${stat.errorCount || 0} |\n`;
                    });
                    markdown += `\n`;
                }

                // Unhealthy evaluations
                const unhealthyEvals = clusterHealth.unhealthyEvaluations;
                if (unhealthyEvals && unhealthyEvals.length > 0) {
                    markdown += `### ‚ö†Ô∏è Unhealthy Evaluations\n\n`;
                    unhealthyEvals.forEach((evaluation: any) => {
                        markdown += `- **${evaluation.kind || 'Unknown'}**: ${evaluation.description || 'No description'}\n`;
                    });
                    markdown += `\n`;
                }

                // Nodes Health Table
                markdown += `## Nodes Health (${nodes.length} nodes)\n\n`;
                markdown += `| Node | Health | Status | Type | Seed |\n|------|--------|--------|------|------|\n`;
                nodes.forEach((node: any) => {
                    markdown += `| ${node.name} | ${healthEmoji(node.healthState || 'Unknown')} ${node.healthState || 'Unknown'} | ${node.nodeStatus || 'Unknown'} | ${node.type || 'Unknown'} | ${node.isSeedNode ? '‚úÖ' : ''} |\n`;
                });
                markdown += `\n`;

                // Unhealthy nodes detail
                const errorNodes = nodes.filter((n: any) => n.healthState === 'Error');
                if (errorNodes.length > 0) {
                    markdown += `### üî¥ Nodes in Error State (${errorNodes.length})\n\n`;
                    errorNodes.forEach((node: any) => {
                        markdown += `#### ${node.name}\n\n- **Status:** ${node.nodeStatus}\n- **Type:** ${node.type}\n- **IP:** ${node.ipAddressOrFQDN}\n- **Upgrade Domain:** ${node.upgradeDomain}\n- **Fault Domain:** ${node.faultDomain}\n\n`;
                    });
                }

                const warningNodes = nodes.filter((n: any) => n.healthState === 'Warning');
                if (warningNodes.length > 0) {
                    markdown += `### üü° Nodes in Warning State (${warningNodes.length})\n\n`;
                    warningNodes.forEach((node: any) => { markdown += `- **${node.name}**: ${node.nodeStatus}\n`; });
                    markdown += `\n`;
                }

                // Applications Health Table
                markdown += `## Applications Health (${applications.length} applications)\n\n`;
                markdown += `| Application | Health | Status | Type | Version |\n|-------------|--------|--------|------|----------|\n`;
                applications.forEach((app: any) => {
                    markdown += `| ${app.name} | ${healthEmoji(app.healthState || 'Unknown')} ${app.healthState || 'Unknown'} | ${app.status || 'Unknown'} | ${app.typeName || 'Unknown'} | ${app.typeVersion || 'Unknown'} |\n`;
                });
                markdown += `\n`;

                // Summary
                const allResources = [...nodes, ...applications];
                const counts = { Ok: 0, Warning: 0, Error: 0, Unknown: 0 };
                allResources.forEach((r: any) => {
                    const hs = r.healthState || 'Unknown';
                    if (hs in counts) { (counts as any)[hs]++; }
                });
                markdown += `---\n\n## Summary\n\n**Total Resources:** ${allResources.length}  \n`;
                markdown += `üü¢ Ok: ${counts.Ok} | üü° Warning: ${counts.Warning} | üî¥ Error: ${counts.Error} | ‚ö™ Unknown: ${counts.Unknown}\n\n`;
                if (counts.Error > 0) { markdown += `‚ö†Ô∏è **Action Required:** ${counts.Error} resource(s) in Error state\n\n`; }
                else if (counts.Warning > 0) { markdown += `‚ÑπÔ∏è **Attention:** ${counts.Warning} resource(s) in Warning state\n\n`; }
                else { markdown += `‚úÖ **All systems healthy**\n\n`; }
                markdown += `---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

                await writeAndOpenReport(context, clusterEndpoint, 'health-report', markdown, progress);
            });
        },
        'generate health report',
    );

    // -----------------------------------------------------------------------
    // generateMetricsReport
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.generateMetricsReport',
        async (item: any) => {
            if (!item || item.itemType !== 'metrics') {
                SfUtility.showWarning('This command is only available for Metrics');
                return;
            }
            const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
            if (!clusterEndpoint) { return; }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating Metrics Report',
                cancellable: false,
            }, async (progress) => {
                progress.report({ increment: 10, message: 'Fetching cluster metrics...' });
                const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
                const loadInfo = await sfRest.getClusterLoadInformation();

                progress.report({ increment: 40, message: 'Processing metrics data...' });
                progress.report({ increment: 30, message: 'Generating markdown...' });

                let markdown = `# Service Fabric Cluster Metrics Report\n\n`;
                markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
                markdown += `**Generated:** ${new Date().toLocaleString()}  \n\n---\n\n`;

                if (loadInfo.lastBalancingStartTimeUtc || loadInfo.lastBalancingEndTimeUtc) {
                    markdown += `## Last Resource Balancing\n\n`;
                    if (loadInfo.lastBalancingStartTimeUtc) { markdown += `**Start Time:** ${new Date(loadInfo.lastBalancingStartTimeUtc).toLocaleString()}  \n`; }
                    if (loadInfo.lastBalancingEndTimeUtc) {
                        markdown += `**End Time:** ${new Date(loadInfo.lastBalancingEndTimeUtc).toLocaleString()}  \n`;
                        if (loadInfo.lastBalancingStartTimeUtc) {
                            const dur = new Date(loadInfo.lastBalancingEndTimeUtc).getTime() - new Date(loadInfo.lastBalancingStartTimeUtc).getTime();
                            markdown += `**Duration:** ${dur}ms  \n`;
                        }
                    }
                    markdown += `\n---\n\n`;
                }

                const metrics = loadInfo.loadMetricInformation;
                if (metrics && metrics.length > 0) {
                    markdown += `## Load Metrics (${metrics.length} metrics)\n\n`;
                    markdown += `| Metric | Cluster Load | Capacity | Usage % | Min Node | Max Node | Balanced |\n|--------|--------------|----------|---------|----------|----------|----------|\n`;

                    metrics.forEach((m: any) => {
                        const load = m.currentClusterLoad || m.clusterLoad || '0';
                        const cap = m.clusterCapacity || 'N/A';
                        const minN = m.minNodeLoadNodeId?.id || 'N/A';
                        const maxN = m.maxNodeLoadNodeId?.id || 'N/A';
                        const bal = m.isBalancedAfter !== undefined ? (m.isBalancedAfter ? '‚úÖ' : '‚ùå') : 'N/A';
                        let pct = 'N/A';
                        if (cap !== 'N/A' && cap !== '0') {
                            const c = parseFloat(cap), l = parseFloat(load);
                            if (!isNaN(c) && !isNaN(l) && c > 0) { pct = `${((l / c) * 100).toFixed(1)}%`; }
                        }
                        markdown += `| ${m.name || 'Unknown'} | ${load} | ${cap} | ${pct} | ${minN} | ${maxN} | ${bal} |\n`;
                    });
                    markdown += `\n## Detailed Metrics\n\n`;

                    metrics.forEach((m: any) => {
                        markdown += `### ${m.name || 'Unknown Metric'}\n\n`;
                        if (m.isClusterCapacityViolation) { markdown += `> ‚ö†Ô∏è **WARNING:** This metric is currently over capacity!\n\n`; }
                        markdown += formatMetricTable(m);
                        markdown += `<details>\n<summary>üìã Full Metric JSON</summary>\n\n\`\`\`json\n${JSON.stringify(m, null, 2)}\n\`\`\`\n</details>\n\n---\n\n`;
                    });
                } else {
                    markdown += `## No Metrics Data\n\nNo load metric information is available for this cluster.\n`;
                }
                markdown += `\n---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

                await writeAndOpenReport(context, clusterEndpoint, 'metrics-report', markdown, progress);
            });
        },
        'generate metrics report',
    );

    // -----------------------------------------------------------------------
    // generateCommandsReference
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.generateCommandsReference',
        async (item: any) => {
            if (!item || item.itemType !== 'commands') {
                SfUtility.showWarning('This command is only available for Commands');
                return;
            }
            const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
            if (!clusterEndpoint) { return; }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating Commands Reference',
                cancellable: false,
            }, async (progress) => {
                progress.report({ increment: 20, message: 'Building command reference...' });
                progress.report({ increment: 40, message: 'Generating markdown...' });

                let markdown = `# Service Fabric Cluster Commands Reference\n\n`;
                markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
                markdown += `**Generated:** ${new Date().toLocaleString()}  \n\n---\n\n`;
                markdown += `## About\n\nThis reference guide contains cluster management commands organized by category.\n\n---\n\n`;

                // Categories
                const categories: [string, string, [string, string, string][]][] = [
                    ['Cluster Operations', 'Commands for managing cluster-level operations.', [
                        ['Start Cluster Upgrade', 'Initiates a cluster upgrade to a new version', 'üü° Medium'],
                        ['Rollback Cluster Upgrade', 'Rolls back an in-progress cluster upgrade', 'üü† High'],
                        ['Update Cluster Configuration', 'Updates cluster configuration settings', 'üü° Medium'],
                        ['Recover System Partitions', 'Recovers system service partitions from seed nodes', 'üî¥ Critical'],
                        ['Reset Partition Loads', 'Resets resource balancer load information', 'üü¢ Low'],
                    ]],
                    ['Application Lifecycle', 'Commands for managing application deployment and upgrades.', [
                        ['Provision Application Type', 'Uploads and provisions an application type to the cluster', 'üü¢ Low'],
                        ['Create Application', 'Creates an application instance from a provisioned type', 'üü¢ Low'],
                        ['Start Application Upgrade', 'Initiates an application upgrade', 'üü° Medium'],
                        ['Rollback Application Upgrade', 'Rolls back an in-progress application upgrade', 'üü† High'],
                    ]],
                    ['Partition & Replica Operations', 'Commands for managing service partitions and replicas.', [
                        ['Move Primary Replica', 'Moves a primary replica to another node', 'üü° Medium'],
                        ['Move Secondary Replica', 'Moves a secondary replica to another node', 'üü¢ Low'],
                        ['Reset Partition Load', 'Resets load information for a specific partition', 'üü¢ Low'],
                        ['Report Custom Health', 'Reports custom health for a cluster entity', 'üü¢ Low'],
                    ]],
                    ['Testing & Chaos', 'Commands for chaos testing and fault injection scenarios.', [
                        ['Start Chaos Test', 'Starts continuous fault injection testing', 'üü† High'],
                        ['Stop Chaos Test', 'Stops an active chaos test', 'üü¢ Low'],
                        ['Query Chaos Events', 'Retrieves events from chaos test runs', 'üü¢ Low'],
                        ['Restart Partition (Data Loss)', 'Forces a partition restart with potential data loss', 'üî¥ Critical'],
                    ]],
                    ['Backup & Restore', 'Commands for backup policy management and restore operations.', [
                        ['Enable Backup', 'Enables periodic backup for a partition', 'üü¢ Low'],
                        ['Disable Backup', 'Disables backup for a partition', 'üü¢ Low'],
                        ['Trigger Ad-hoc Backup', 'Triggers an immediate one-time backup', 'üü¢ Low'],
                        ['Get Backup Progress', 'Queries the status of a backup operation', 'üü¢ Low'],
                        ['Restore from Backup', 'Restores a partition from a backup', 'üü† High'],
                    ]],
                    ['Repair & Infrastructure', 'Commands for repair task management and infrastructure operations.', [
                        ['View Active Repair Tasks', 'Lists all active repair tasks in the cluster', 'üü¢ Low'],
                        ['Create Repair Task', 'Creates a new repair task', 'üü° Medium'],
                        ['Cancel Repair Task', 'Cancels a pending repair task', 'üü° Medium'],
                        ['Force Approve Repair Task', 'Forces approval (bypasses safety checks)', 'üî¥ Critical'],
                    ]],
                ];

                categories.forEach(([title, desc, cmds]) => {
                    markdown += `## ${title}\n\n${desc}\n\n`;
                    markdown += `| Command | Description | Risk Level |\n|---------|-------------|------------|\n`;
                    cmds.forEach(([name, description, risk]) => {
                        markdown += `| **${name}** | ${description} | ${risk} |\n`;
                    });
                    markdown += `\n`;
                });

                // Risk legend + best practices
                markdown += `---\n\n## Risk Level Legend\n\n| Symbol | Level | Description |\n|--------|-------|-------------|\n`;
                markdown += `| üü¢ | **Low** | Safe operations with minimal impact |\n`;
                markdown += `| üü° | **Medium** | May cause temporary disruption |\n`;
                markdown += `| üü† | **High** | Can cause service interruption |\n`;
                markdown += `| üî¥ | **Critical** | Dangerous ‚Äî requires extreme caution |\n\n`;
                markdown += `---\n\n## Best Practices\n\n`;
                markdown += `1. **Always validate cluster health** before executing high-risk commands\n`;
                markdown += `2. **Use Chaos testing** only in pre-production/test environments\n`;
                markdown += `3. **Test upgrades** in a development environment first\n`;
                markdown += `4. **Monitor progress** during and after executing commands\n`;
                markdown += `5. **Have a rollback plan** for critical operations\n`;
                markdown += `6. **Document changes** for audit and troubleshooting\n\n`;
                markdown += `---\n\n*Reference generated by Service Fabric Diagnostic Extension*\n`;

                await writeAndOpenReport(context, clusterEndpoint, 'commands-reference', markdown, progress);
            });
        },
        'generate commands reference',
    );

    // -----------------------------------------------------------------------
    // generateEssentialsReport
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.generateEssentialsReport',
        async (item: any) => {
            if (!item || item.itemType !== 'essentials') {
                SfUtility.showWarning('This command is only available for Cluster Essentials');
                return;
            }
            const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
            if (!clusterEndpoint) { return; }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating Cluster Essentials Report',
                cancellable: false,
            }, async (progress) => {
                progress.report({ increment: 10, message: 'Fetching cluster data...' });
                const sfRest = sfMgr.getCurrentSfConfig().getSfRest();

                const [health, version, manifest, nodes, applications] = await Promise.all([
                    sfRest.getClusterHealth(),
                    sfRest.getClusterVersion(),
                    sfRest.getClusterManifest(),
                    sfRest.getNodes(),
                    sfRest.getApplications(),
                ]);

                progress.report({ increment: 40, message: 'Analyzing cluster health...' });

                // Parse manifest for FD/UD
                let faultDomainCount = 'N/A', upgradeDomainCount = 'N/A';
                try {
                    const manifestXml = (manifest as any).manifest;
                    if (manifestXml) {
                        const fdMatch = manifestXml.match(/FaultDomainCount="(\d+)"/i);
                        const udMatch = manifestXml.match(/UpgradeDomainCount="(\d+)"/i);
                        if (fdMatch) { faultDomainCount = fdMatch[1]; }
                        if (udMatch) { upgradeDomainCount = udMatch[1]; }
                    }
                } catch (_) { /* ignore */ }

                const healthState = health.aggregatedHealthState || 'Unknown';
                const healthIcon = healthState === 'Ok' ? '‚úÖ' : healthState === 'Warning' ? '‚ö†Ô∏è' : healthState === 'Error' ? '‚ùå' : '‚ÑπÔ∏è';

                const nodeStates = health.nodeHealthStates || [];
                const appStates = health.applicationHealthStates || [];
                const healthEvents = health.healthEvents || [];
                const unhealthyEvals = health.unhealthyEvaluations || [];

                const nodeTypeMap = new Map<string, number>();
                (nodes || []).forEach((n: any) => {
                    const t = n.type || 'Unknown';
                    nodeTypeMap.set(t, (nodeTypeMap.get(t) || 0) + 1);
                });

                let versionString = 'Unknown';
                if (version) { versionString = (version as any).version || (version as any).Version || (typeof version === 'string' ? version : 'Unknown'); }

                progress.report({ increment: 30, message: 'Generating report...' });

                const countByState = (items: any[]) => ({
                    ok: items.filter((x: any) => x.aggregatedHealthState === 'Ok').length,
                    warning: items.filter((x: any) => x.aggregatedHealthState === 'Warning').length,
                    error: items.filter((x: any) => x.aggregatedHealthState === 'Error').length,
                    total: items.length,
                });
                const nodeStats = countByState(nodeStates);
                const appStats = countByState(appStates);
                const pct = (n: number, t: number) => t > 0 ? ((n / t) * 100).toFixed(1) : '0';

                const errorEvents = healthEvents.filter((e: any) => e.healthInformation?.healthState === 'Error').length;
                const warningEvents = healthEvents.filter((e: any) => e.healthInformation?.healthState === 'Warning').length;

                let reportContent = `# üîç Service Fabric Cluster Essentials Report\n\n**Generated:** ${new Date().toLocaleString()}  \n**Cluster:** \`${clusterEndpoint}\`\n\n---\n\n`;
                reportContent += `## üìä Cluster Summary\n\n| Property | Value |\n|----------|-------|\n`;
                reportContent += `| **Service Fabric Version** | ${versionString} |\n`;
                reportContent += `| **Health State** | ${healthIcon} **${healthState}** |\n`;
                reportContent += `| **Fault Domain Count** | ${faultDomainCount} |\n`;
                reportContent += `| **Upgrade Domain Count** | ${upgradeDomainCount} |\n`;
                reportContent += `| **Total Nodes** | ${(nodes || []).length} |\n`;
                reportContent += `| **Total Applications** | ${(applications || []).length} |\n\n---\n\n`;

                reportContent += `## üñ•Ô∏è Node Health Statistics\n\n| State | Count | Percentage |\n|-------|-------|------------|\n`;
                reportContent += `| ‚úÖ **Healthy** | ${nodeStats.ok} | ${pct(nodeStats.ok, nodeStats.total)}% |\n`;
                reportContent += `| ‚ö†Ô∏è **Warning** | ${nodeStats.warning} | ${pct(nodeStats.warning, nodeStats.total)}% |\n`;
                reportContent += `| ‚ùå **Error** | ${nodeStats.error} | ${pct(nodeStats.error, nodeStats.total)}% |\n`;
                reportContent += `| **Total** | **${nodeStats.total}** | **100%** |\n\n`;
                reportContent += `### Node Type Distribution\n\n${Array.from(nodeTypeMap.entries()).map(([t, c]) => `- **${t}**: ${c} node(s)`).join('\n')}\n\n---\n\n`;

                reportContent += `## üì¶ Application Health Statistics\n\n| State | Count | Percentage |\n|-------|-------|------------|\n`;
                reportContent += `| ‚úÖ **Healthy** | ${appStats.ok} | ${pct(appStats.ok, appStats.total)}% |\n`;
                reportContent += `| ‚ö†Ô∏è **Warning** | ${appStats.warning} | ${pct(appStats.warning, appStats.total)}% |\n`;
                reportContent += `| ‚ùå **Error** | ${appStats.error} | ${pct(appStats.error, appStats.total)}% |\n`;
                reportContent += `| **Total** | **${appStats.total}** | **100%** |\n\n---\n\n`;

                reportContent += `## ü©∫ Health Events Summary\n\n| Type | Count |\n|------|-------|\n`;
                reportContent += `| ‚ùå **Error Events** | ${errorEvents} |\n`;
                reportContent += `| ‚ö†Ô∏è **Warning Events** | ${warningEvents} |\n`;
                reportContent += `| ‚ÑπÔ∏è **Informational** | ${healthEvents.length - errorEvents - warningEvents} |\n`;
                reportContent += `| **Total Events** | **${healthEvents.length}** |\n\n`;

                if (unhealthyEvals.length > 0) {
                    reportContent += `### ‚ö†Ô∏è Unhealthy Evaluations\n\n> **Warning:** ${unhealthyEvals.length} unhealthy evaluation(s) detected\n\n`;
                    reportContent += `<details>\n<summary>Click to view</summary>\n\n\`\`\`json\n${JSON.stringify(unhealthyEvals, null, 2)}\n\`\`\`\n\n</details>\n\n`;
                } else {
                    reportContent += `### ‚úÖ No Unhealthy Evaluations\n\n`;
                }

                reportContent += `---\n\n*Report generated by Service Fabric Cluster Explorer extension*\n`;

                const doc = await vscode.workspace.openTextDocument({ content: reportContent, language: 'markdown' });
                await vscode.window.showTextDocument(doc, { preview: false });
                progress.report({ increment: 100, message: 'Report generated!' });
                SfUtility.showInformation('‚úÖ Cluster essentials report generated successfully!');
            });
        },
        'generate essentials report',
    );

    // -----------------------------------------------------------------------
    // generateRepairTasksReport
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.generateRepairTasksReport',
        async (item: any) => {
            if (!item || item.itemType !== 'repair-tasks') {
                SfUtility.showWarning('This command is only available for Repair Tasks');
                return;
            }
            const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
            if (!clusterEndpoint) { return; }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating Repair Tasks Report',
                cancellable: false,
            }, async (progress) => {
                progress.report({ increment: 10, message: 'Fetching repair tasks...' });
                const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
                const tasks = await sfRest.getRepairTasks();

                progress.report({ increment: 40, message: `Processing ${tasks.length} tasks...` });
                progress.report({ increment: 30, message: 'Generating markdown...' });

                let markdown = `# Service Fabric Repair Tasks Report\n\n`;
                markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
                markdown += `**Generated:** ${new Date().toLocaleString()}  \n`;
                markdown += `**Total Tasks:** ${tasks.length}  \n\n---\n\n`;

                if (tasks.length === 0) {
                    markdown += `## No Repair Tasks Found\n\nNo repair tasks are currently active or have been executed recently.\n`;
                } else {
                    // Group by state / result / action / node
                    const byState = groupBy(tasks, (t: any) => t.state || 'Unknown');
                    const byResult = groupBy(tasks, (t: any) => t.resultStatus || 'Pending');
                    const byAction = groupBy(tasks, (t: any) => t.action || 'Unknown');
                    const byNode = new Map<string, any[]>();
                    tasks.forEach((t: any) => {
                        (t.target?.nodeNames || []).forEach((n: string) => {
                            if (!byNode.has(n)) { byNode.set(n, []); }
                            byNode.get(n)!.push(t);
                        });
                    });

                    const stateEmojis: Record<string, string> = { Completed: '‚úÖ', Approved: 'üëç', Executing: '‚öôÔ∏è', Restoring: 'üîÑ', Preparing: 'üìã', Claimed: 'ü§ù', Created: 'üÜï', Invalid: '‚ùå' };
                    const resultEmojis: Record<string, string> = { Succeeded: '‚úÖ', Pending: '‚è≥', Cancelled: 'üö´', Interrupted: '‚ö†Ô∏è', Failed: '‚ùå' };

                    markdown += `## Summary\n\n### By State\n\n| State | Count | Emoji |\n|-------|-------|-------|\n`;
                    sortedEntries(byState).forEach(([s, ts]) => { markdown += `| ${s} | ${ts.length} | ${stateEmojis[s] || '‚ö™'} |\n`; });
                    markdown += `\n### By Result Status\n\n| Status | Count | Emoji |\n|--------|-------|-------|\n`;
                    sortedEntries(byResult).forEach(([r, ts]) => { markdown += `| ${r} | ${ts.length} | ${resultEmojis[r] || '‚ö™'} |\n`; });
                    markdown += `\n### By Action Type\n\n| Action | Count |\n|--------|-------|\n`;
                    sortedEntries(byAction).forEach(([a, ts]) => { markdown += `| ${a} | ${ts.length} |\n`; });
                    markdown += `\n### Impact by Node\n\n| Node | Task Count |\n|------|------------|\n`;
                    sortedEntries(byNode).forEach(([n, ts]) => { markdown += `| ${n} | ${ts.length} |\n`; });
                    markdown += `\n---\n\n## Detailed Task List\n\n`;

                    const sorted = [...tasks].sort((a: any, b: any) => {
                        const tA = a.history?.createdUtcTimestamp ? new Date(a.history.createdUtcTimestamp).getTime() : 0;
                        const tB = b.history?.createdUtcTimestamp ? new Date(b.history.createdUtcTimestamp).getTime() : 0;
                        return tB - tA;
                    });

                    sorted.forEach((task: any, idx: number) => {
                        const state = task.state || 'Unknown';
                        const result = task.resultStatus || 'Pending';
                        markdown += `### ${idx + 1}. ${stateEmojis[state] || '‚ö™'} Task: ${task.taskId}\n\n`;
                        markdown += `<table>\n`;
                        markdown += `<tr><td><strong>Property</strong></td><td><strong>Value</strong></td></tr>\n`;
                        markdown += `<tr><td>State</td><td><strong>${stateEmojis[state] || '‚ö™'} ${state}</strong></td></tr>\n`;
                        markdown += `<tr><td>Result Status</td><td><strong>${resultEmojis[result] || '‚ö™'} ${result}</strong></td></tr>\n`;
                        if (task.action) { markdown += `<tr><td>Action</td><td><code>${task.action}</code></td></tr>\n`; }
                        if (task.executor) { markdown += `<tr><td>Executor</td><td><code>${task.executor}</code></td></tr>\n`; }
                        if (task.target?.nodeNames) {
                            markdown += `<tr><td>Target Nodes</td><td>${task.target.nodeNames.map((n: string) => `<code>${n}</code>`).join(', ')}</td></tr>\n`;
                        }
                        if (task.impact?.nodeImpactList) {
                            markdown += `<tr><td>Impact Level</td><td><strong>${task.impact.nodeImpactList.map((i: any) => i.impactLevel).join(', ')}</strong></td></tr>\n`;
                        }
                        if (task.resultDetails) { markdown += `<tr><td>Result Details</td><td>${task.resultDetails}</td></tr>\n`; }
                        if (task.resultCode !== undefined) { markdown += `<tr><td>Result Code</td><td>${task.resultCode}</td></tr>\n`; }

                        if (task.history) {
                            markdown += `<tr><td colspan="2"><hr></td></tr>\n<tr><td colspan="2"><strong>Timeline</strong></td></tr>\n`;
                            const h = task.history;
                            for (const [label, key] of [['Created', 'createdUtcTimestamp'], ['Claimed', 'claimedUtcTimestamp'], ['Preparing', 'preparingUtcTimestamp'], ['Approved', 'approvedUtcTimestamp'], ['Executing', 'executingUtcTimestamp'], ['Restoring', 'restoringUtcTimestamp'], ['Completed', 'completedUtcTimestamp']]) {
                                if (h[key]) { markdown += `<tr><td>${label}</td><td>${new Date(h[key]).toLocaleString()}</td></tr>\n`; }
                            }
                            if (h.completedUtcTimestamp && h.createdUtcTimestamp) {
                                const dur = new Date(h.completedUtcTimestamp).getTime() - new Date(h.createdUtcTimestamp).getTime();
                                markdown += `<tr><td><strong>Total Duration</strong></td><td><strong>${Math.floor(dur / 60000)}m ${Math.floor((dur % 60000) / 1000)}s</strong></td></tr>\n`;
                            }
                        }
                        markdown += `</table>\n\n`;
                        markdown += `<details>\n<summary>üìã Full Task JSON</summary>\n\n\`\`\`json\n${JSON.stringify(task, null, 2)}\n\`\`\`\n</details>\n\n---\n\n`;
                    });
                }
                markdown += `\n---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

                await writeAndOpenReport(context, clusterEndpoint, 'repair-tasks-report', markdown, progress);
            });
        },
        'generate repair tasks report',
    );

    // -----------------------------------------------------------------------
    // exportSnapshot
    // -----------------------------------------------------------------------
    registerCommandWithErrorHandling(
        context,
        'sfClusterExplorer.exportSnapshot',
        async (item: any) => {
            if (!item) {
                SfUtility.showWarning('No item selected for snapshot export');
                return;
            }
            const itemLabel = item.label || 'unknown';
            const itemType = item.itemType || 'item';
            const clusterEndpoint = item.clusterEndpoint || 'unknown-cluster';

            const snapshot = serializeTreeItem(item);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const safeName = itemLabel.replace(/[^a-zA-Z0-9-_]/g, '_');
            const fileName = `snapshot-${itemType}-${safeName}-${timestamp}.json`;
            const clusterName = clusterEndpoint.replace(/[^a-zA-Z0-9]/g, '_');
            const dirPath = path.join(context.globalStorageUri.fsPath, clusterName, 'snapshots');
            await vscode.workspace.fs.createDirectory(vscode.Uri.file(dirPath));

            const filePath = path.join(dirPath, fileName);
            await vscode.workspace.fs.writeFile(
                vscode.Uri.file(filePath),
                new TextEncoder().encode(JSON.stringify(snapshot, null, 2)),
            );

            SfUtility.outputLog(`Snapshot saved to: ${filePath}`, null, debugLevel.info);
            const choice = await vscode.window.showInformationMessage(`Snapshot saved: ${fileName}`, 'Open', 'Show in Folder');
            if (choice === 'Open') {
                const doc = await vscode.workspace.openTextDocument(filePath);
                await vscode.window.showTextDocument(doc, { preview: false });
            } else if (choice === 'Show in Folder') {
                await vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(filePath));
            }
        },
        'export snapshot',
    );
}

// ===========================================================================
// Shared helpers
// ===========================================================================

function resolveClusterEndpoint(item: any, sfMgr: SfMgr): string | undefined {
    const endpoint = item?.clusterEndpoint || sfMgr.getCurrentSfConfig().getClusterEndpoint();
    if (!endpoint) {
        SfUtility.showWarning('No cluster endpoint available');
    }
    return endpoint;
}

function healthEmoji(state: string): string {
    if (state === 'Error') { return 'üî¥'; }
    if (state === 'Warning') { return 'üü°'; }
    if (state === 'Ok') { return 'üü¢'; }
    return '‚ö™';
}

/**
 * Infer health state from event kind/content when HealthState is absent.
 */
function inferEventHealthState(event: any): string {
    const explicit = event.HealthState || event.healthState;
    if (explicit && explicit !== 'Unknown') { return explicit; }

    const combined = `${(event.Kind || event.kind || '')} ${(event.Description || event.description || '')}`.toLowerCase();
    if (combined.match(/error|failed|failure|fault|unhealthy|down|critical|invalid/)) { return 'Error'; }
    if (combined.match(/warning|degrad|slow|timeout|retry/)) { return 'Warning'; }
    if (combined.match(/completed|started|created|healthy|ok|success|up|ready|deployed|upgraded|activated|opened|closed|new|cleared|resolved/)) { return 'Ok'; }
    if ((event.Kind || event.kind || '').toLowerCase().includes('health')) { return 'Ok'; }
    return 'Unknown';
}

function healthCounts(events: any[]): Record<string, number> {
    const counts: Record<string, number> = { Error: 0, Warning: 0, Ok: 0, Unknown: 0 };
    events.forEach((e: any) => {
        const h = inferEventHealthState(e);
        if (h in counts) { counts[h]++; }
    });
    return counts;
}

function groupBy<T>(items: T[], keyFn: (item: T) => string): Map<string, T[]> {
    const map = new Map<string, T[]>();
    items.forEach(item => {
        const key = keyFn(item);
        if (!map.has(key)) { map.set(key, []); }
        map.get(key)!.push(item);
    });
    return map;
}

function sortedEntries<T>(map: Map<string, T[]>): [string, T[]][] {
    return [...map.entries()].sort((a, b) => b[1].length - a[1].length);
}

function formatEventDetail(event: any): string {
    const ts = event.TimeStamp || event.timeStamp || event.eventInstanceId;
    const kind = event.Kind || event.kind || 'Event';
    const hs = inferEventHealthState(event);
    const emoji = hs === 'Error' ? 'üî¥' : hs === 'Warning' ? 'üü°' : hs === 'Ok' ? 'üü¢' : '‚ö™';

    let md = `#### ${emoji} ${kind}\n\n<table>\n`;
    md += `<tr><td><strong>Property</strong></td><td><strong>Value</strong></td></tr>\n`;
    if (ts) {
        try {
            const d = new Date(ts);
            md += `<tr><td>Time</td><td>${!isNaN(d.getTime()) ? d.toLocaleString() : ts}</td></tr>\n`;
        } catch (_) { md += `<tr><td>Time</td><td>${ts}</td></tr>\n`; }
    }
    md += `<tr><td>Health State</td><td><strong>${emoji} ${hs}</strong></td></tr>\n`;
    const fields: [string, string][] = [
        ['Category', 'Category'], ['Category', 'category'],
        ['Node', 'NodeName'], ['Node', 'nodeName'],
        ['Application', 'ApplicationName'], ['Application', 'applicationName'],
        ['Service', 'ServiceName'], ['Service', 'serviceName'],
        ['Partition ID', 'PartitionId'], ['Partition ID', 'partitionId'],
        ['Replica ID', 'ReplicaId'], ['Replica ID', 'replicaId'],
        ['Source ID', 'SourceId'], ['Source ID', 'sourceId'],
        ['Property', 'Property'], ['Property', 'property'],
        ['Description', 'Description'],
        ['Reason', 'Reason'], ['Reason', 'reason'],
        ['Error', 'Error'], ['Error', 'error'],
    ];
    const seen = new Set<string>();
    fields.forEach(([label, key]) => {
        if (event[key] && !seen.has(label)) {
            seen.add(label);
            md += `<tr><td>${label}</td><td>${label === 'Node' || label === 'Source ID' || label === 'Partition ID' || label === 'Replica ID' || label === 'Error' ? `<code>${event[key]}</code>` : event[key]}</td></tr>\n`;
        }
    });
    if (event.SequenceNumber !== undefined) { md += `<tr><td>Sequence Number</td><td>${event.SequenceNumber}</td></tr>\n`; }
    md += `</table>\n\n`;
    md += `<details>\n<summary>üìã Full Event JSON</summary>\n\n\`\`\`json\n${JSON.stringify(event, null, 2)}\n\`\`\`\n</details>\n\n---\n\n`;
    return md;
}

function formatMetricTable(m: any): string {
    let md = `<table>\n<tr><td><strong>Property</strong></td><td><strong>Value</strong></td></tr>\n`;
    if (m.clusterCapacity !== undefined) { md += `<tr><td>Total Capacity</td><td><strong>${m.clusterCapacity}</strong></td></tr>\n`; }
    const load = m.currentClusterLoad ?? m.clusterLoad;
    if (load !== undefined) { md += `<tr><td>Current Load</td><td><strong>${load}</strong></td></tr>\n`; }
    const remaining = m.clusterCapacityRemaining ?? m.clusterRemainingCapacity;
    if (remaining !== undefined) { md += `<tr><td>Remaining Capacity</td><td><strong>${remaining}</strong></td></tr>\n`; }
    const buffered = m.bufferedClusterCapacityRemaining ?? m.clusterBufferedCapacity;
    if (buffered !== undefined) { md += `<tr><td>Buffered Capacity Remaining</td><td>${buffered}</td></tr>\n`; }
    if (m.nodeBufferPercentage !== undefined) { md += `<tr><td>Node Buffer %</td><td>${m.nodeBufferPercentage}%</td></tr>\n`; }
    md += `<tr><td colspan="2"><hr></td></tr>\n`;
    if (m.minimumNodeLoad !== undefined || m.minNodeLoadValue !== undefined) { md += `<tr><td>Min Node Load</td><td><strong>${m.minimumNodeLoad || m.minNodeLoadValue}</strong> (${m.minNodeLoadNodeId?.id || 'Unknown'})</td></tr>\n`; }
    if (m.maximumNodeLoad !== undefined || m.maxNodeLoadValue !== undefined) { md += `<tr><td>Max Node Load</td><td><strong>${m.maximumNodeLoad || m.maxNodeLoadValue}</strong> (${m.maxNodeLoadNodeId?.id || 'Unknown'})</td></tr>\n`; }
    md += `<tr><td colspan="2"><hr></td></tr>\n`;
    if (m.isBalancedBefore !== undefined) { md += `<tr><td>Balanced Before</td><td>${m.isBalancedBefore ? '‚úÖ Yes' : '‚ùå No'}</td></tr>\n`; }
    if (m.isBalancedAfter !== undefined) { md += `<tr><td>Balanced After</td><td>${m.isBalancedAfter ? '‚úÖ Yes' : '‚ùå No'}</td></tr>\n`; }
    if (m.deviationBefore !== undefined) { md += `<tr><td>Deviation Before</td><td>${m.deviationBefore}</td></tr>\n`; }
    if (m.deviationAfter !== undefined) { md += `<tr><td>Deviation After</td><td>${m.deviationAfter}</td></tr>\n`; }
    md += `<tr><td colspan="2"><hr></td></tr>\n`;
    if (m.balancingThreshold !== undefined) { md += `<tr><td>Balancing Threshold</td><td>${m.balancingThreshold}</td></tr>\n`; }
    if (m.activityThreshold !== undefined) { md += `<tr><td>Activity Threshold</td><td>${m.activityThreshold}</td></tr>\n`; }
    if (m.action !== undefined) { md += `<tr><td>Current Action</td><td><em>${m.action}</em></td></tr>\n`; }
    if (m.isClusterCapacityViolation !== undefined) { md += `<tr><td>Capacity Violation</td><td><strong>${m.isClusterCapacityViolation ? '‚ö†Ô∏è YES' : '‚úÖ No'}</strong></td></tr>\n`; }
    md += `</table>\n\n`;
    return md;
}

async function writeAndOpenReport(
    context: vscode.ExtensionContext,
    clusterEndpoint: string,
    prefix: string,
    markdown: string,
    progress: vscode.Progress<{ message?: string; increment?: number }>,
): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    const fileName = `${prefix}-${timestamp}.md`;
    const clusterName = clusterEndpoint.replace(/[^a-zA-Z0-9]/g, '_');
    const dirPath = path.join(context.globalStorageUri.fsPath, clusterName, 'reports');
    await vscode.workspace.fs.createDirectory(vscode.Uri.file(dirPath));

    const filePath = path.join(dirPath, fileName);
    await vscode.workspace.fs.writeFile(vscode.Uri.file(filePath), new TextEncoder().encode(markdown));

    progress.report({ increment: 20, message: 'Opening report...' });
    SfUtility.outputLog(`Report saved to: ${filePath}`, null, debugLevel.info);

    const doc = await vscode.workspace.openTextDocument(filePath);
    await vscode.window.showTextDocument(doc, { preview: false });
    await vscode.commands.executeCommand('markdown.showPreview', vscode.Uri.file(filePath));
    SfUtility.showInformation(`Report generated: ${fileName}`);
}

/**
 * Serialize tree item to JSON (including children recursively).
 * Moved from extension.ts.
 */
function serializeTreeItem(item: any, depth: number = 0, maxDepth: number = 10): any {
    if (depth > maxDepth) { return { _truncated: true, message: 'Max depth reached' }; }

    const serialized: any = {
        label: item.label,
        itemType: item.itemType,
        itemId: item.itemId,
        tooltip: item.tooltip,
        description: item.description,
        healthState: item.healthState,
        clusterEndpoint: item.clusterEndpoint,
        applicationId: item.applicationId,
        serviceId: item.serviceId,
        partitionId: item.partitionId,
        replicaId: item.replicaId,
        contextValue: item.contextValue,
        collapsibleState: item.collapsibleState,
    };

    if (item.children && Array.isArray(item.children) && item.children.length > 0) {
        serialized.children = item.children.map((child: any) => serializeTreeItem(child, depth + 1, maxDepth));
        serialized._childCount = item.children.length;
    }

    Object.keys(serialized).forEach(key => {
        if (serialized[key] === undefined || serialized[key] === null) { delete serialized[key]; }
    });
    return serialized;
}
