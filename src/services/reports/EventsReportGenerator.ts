/**
 * Events report generator.
 */

import * as vscode from 'vscode';
import { SfMgr } from '../../sfMgr';
import { SfUtility } from '../../sfUtility';
import {
    resolveClusterEndpoint,
    healthCounts,
    groupBy,
    sortedEntries,
    formatEventDetail,
    writeAndOpenReport,
} from './ReportUtils';

export async function generateEventsReport(
    context: vscode.ExtensionContext,
    sfMgr: SfMgr,
    item: any,
): Promise<void> {
    if (!item || item.itemType !== 'events') {
        SfUtility.showWarning('This command is only available for Events');
        return;
    }
    const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
    if (!clusterEndpoint) { return; }

    await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Generating Events Report',
        cancellable: false,
    }, async (progress) => {
        progress.report({ increment: 10, message: 'Fetching cluster events...' });

        const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
        const endTime = new Date();
        const startTime = new Date();
        startTime.setDate(startTime.getDate() - 7);
        const events = await sfRest.getClusterEvents(startTime.toISOString(), endTime.toISOString());

        progress.report({ increment: 40, message: `Processing ${events.length} events...` });
        progress.report({ increment: 30, message: 'Generating markdown...' });

        let markdown = `# Service Fabric Cluster Events Report\n\n`;
        markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
        markdown += `**Generated:** ${new Date().toLocaleString()}  \n`;
        markdown += `**Period:** ${startTime.toLocaleDateString()} - ${endTime.toLocaleDateString()}  \n`;
        markdown += `**Total Events:** ${events.length}  \n\n---\n\n`;

        if (events.length === 0) {
            markdown += `## No Events Found\n\nNo cluster events were found in the EventStore for the specified time period.\n`;
        } else {
            const eventsByKind = groupBy(events, (e: any) => e.Kind || e.kind || 'Other');

            markdown += `## Event Summary\n\n`;
            markdown += `| Event Type | Count | Health ðŸ”´ðŸŸ¡ðŸŸ¢ |\n|------------|-------|-------------|\n`;
            sortedEntries(eventsByKind).forEach(([kind, kindEvents]) => {
                const counts = healthCounts(kindEvents);
                markdown += `| ${kind} | ${kindEvents.length} | ðŸ”´${counts.Error} ðŸŸ¡${counts.Warning} ðŸŸ¢${counts.Ok} |\n`;
            });
            markdown += `\n`;

            const totalCounts = healthCounts(events);
            markdown += `**Overall Health Distribution:**  \n`;
            markdown += `ðŸ”´ Error: ${totalCounts.Error} | ðŸŸ¡ Warning: ${totalCounts.Warning} | ðŸŸ¢ Ok: ${totalCounts.Ok} | âšª Unknown: ${totalCounts.Unknown}\n\n---\n\n`;

            markdown += `## Detailed Events\n\n`;
            sortedEntries(eventsByKind).forEach(([kind, kindEvents]) => {
                markdown += `### ${kind} (${kindEvents.length} events)\n\n`;
                const sorted = [...kindEvents].sort((a: any, b: any) => {
                    const tA = new Date(a.TimeStamp || a.timeStamp || 0).getTime();
                    const tB = new Date(b.TimeStamp || b.timeStamp || 0).getTime();
                    return tB - tA;
                });
                sorted.forEach((event: any) => {
                    markdown += formatEventDetail(event);
                });
            });
        }
        markdown += `\n---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

        await writeAndOpenReport(context, clusterEndpoint, 'events-report', markdown, progress);
    });
}
