/**
 * Events report generator.
 */

import * as vscode from 'vscode';
import { SfMgr } from '../../sfMgr';
import { SfUtility } from '../../sfUtility';
import {
    resolveClusterEndpoint,
    healthCounts,
    groupBy,
    sortedEntries,
    formatEventDetail,
    writeAndOpenReport,
} from './ReportUtils';

export async function generateEventsReport(
    context: vscode.ExtensionContext,
    sfMgr: SfMgr,
    item: any,
): Promise<void> {
    // Use contextValue (clean type like 'app-events') instead of itemType
    // which may be compound (e.g. 'app-events:MyAppId')
    const effectiveType = item?.contextValue || (item?.itemType || '').split(':')[0] || '';
    if (!item || !effectiveType.endsWith('events')) {
        SfUtility.showWarning('This command is only available for Events items');
        return;
    }
    const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
    if (!clusterEndpoint) { return; }

    await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Generating Events Report',
        cancellable: false,
    }, async (progress) => {
        const itemType = effectiveType;
        const entityLabel = getEntityLabel(itemType, item);
        progress.report({ increment: 10, message: `Fetching ${entityLabel} events...` });

        const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
        const endTime = new Date();
        const startTime = new Date();
        startTime.setDate(startTime.getDate() - 7);
        const events = await fetchEventsForItemType(sfRest, itemType, item, startTime.toISOString(), endTime.toISOString());

        progress.report({ increment: 40, message: `Processing ${events.length} events...` });
        progress.report({ increment: 30, message: 'Generating markdown...' });

        let markdown = `# Service Fabric ${entityLabel} Events Report\n\n`;
        markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
        if (item.nodeName) { markdown += `**Node:** \`${item.nodeName}\`  \n`; }
        if (item.applicationId) { markdown += `**Application:** \`${item.applicationId}\`  \n`; }
        if (item.serviceId) { markdown += `**Service:** \`${item.serviceId}\`  \n`; }
        if (item.partitionId) { markdown += `**Partition:** \`${item.partitionId}\`  \n`; }
        if (item.replicaId) { markdown += `**Replica:** \`${item.replicaId}\`  \n`; }
        markdown += `**Generated:** ${new Date().toLocaleString()}  \n`;
        markdown += `**Period:** ${startTime.toLocaleDateString()} - ${endTime.toLocaleDateString()}  \n`;
        markdown += `**Total Events:** ${events.length}  \n\n---\n\n`;

        if (events.length === 0) {
            markdown += `## No Events Found\n\nNo cluster events were found in the EventStore for the specified time period.\n`;
        } else {
            const eventsByKind = groupBy(events, (e: any) => e.Kind || e.kind || 'Other');

            markdown += `## Event Summary\n\n`;
            markdown += `| Event Type | Count | Health ðŸ”´ðŸŸ¡ðŸŸ¢ |\n|------------|-------|-------------|\n`;
            sortedEntries(eventsByKind).forEach(([kind, kindEvents]) => {
                const counts = healthCounts(kindEvents);
                markdown += `| ${kind} | ${kindEvents.length} | ðŸ”´${counts.Error} ðŸŸ¡${counts.Warning} ðŸŸ¢${counts.Ok} |\n`;
            });
            markdown += `\n`;

            const totalCounts = healthCounts(events);
            markdown += `**Overall Health Distribution:**  \n`;
            markdown += `ðŸ”´ Error: ${totalCounts.Error} | ðŸŸ¡ Warning: ${totalCounts.Warning} | ðŸŸ¢ Ok: ${totalCounts.Ok} | âšª Unknown: ${totalCounts.Unknown}\n\n---\n\n`;

            markdown += `## Detailed Events\n\n`;
            sortedEntries(eventsByKind).forEach(([kind, kindEvents]) => {
                markdown += `### ${kind} (${kindEvents.length} events)\n\n`;
                const sorted = [...kindEvents].sort((a: any, b: any) => {
                    const tA = new Date(a.TimeStamp || a.timeStamp || 0).getTime();
                    const tB = new Date(b.TimeStamp || b.timeStamp || 0).getTime();
                    return tB - tA;
                });
                sorted.forEach((event: any) => {
                    markdown += formatEventDetail(event);
                });
            });
        }
        markdown += `\n---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

        await writeAndOpenReport(context, clusterEndpoint, 'events-report', markdown, progress);
    });
}

/** Fetch events based on the item type context */
async function fetchEventsForItemType(
    sfRest: any, itemType: string, item: any,
    startTime: string, endTime: string,
): Promise<any[]> {
    switch (itemType) {
        case 'node-events':
            if (item.nodeName) {
                return sfRest.getNodeEvents?.(item.nodeName, startTime, endTime) 
                    ?? sfRest.getClusterEvents(startTime, endTime);
            }
            return sfRest.getClusterEvents(startTime, endTime);
        case 'app-events':
        case 'application-events':
            if (item.applicationId) {
                return sfRest.getApplicationEvents?.(item.applicationId, startTime, endTime)
                    ?? sfRest.getClusterEvents(startTime, endTime);
            }
            return sfRest.getClusterEvents(startTime, endTime);
        case 'svc-events':
        case 'service-events':
            if (item.serviceId) {
                return sfRest.getServiceEvents(item.serviceId, startTime, endTime);
            }
            return sfRest.getClusterEvents(startTime, endTime);
        case 'part-events':
        case 'partition-events':
            if (item.partitionId) {
                return sfRest.getPartitionEvents(item.partitionId, startTime, endTime);
            }
            return sfRest.getClusterEvents(startTime, endTime);
        case 'rep-events':
        case 'replica-events':
            if (item.replicaId && item.partitionId) {
                return sfRest.getReplicaEvents(item.replicaId, item.partitionId, startTime, endTime);
            }
            return sfRest.getClusterEvents(startTime, endTime);
        default:
            return sfRest.getClusterEvents(startTime, endTime);
    }
}

/** Get a human-readable label for the entity type */
function getEntityLabel(itemType: string, item: any): string {
    switch (itemType) {
        case 'node-events': return `Node (${item.nodeName || 'Unknown'})`;
        case 'app-events':
        case 'application-events': return `Application (${item.applicationId || 'Unknown'})`;
        case 'svc-events':
        case 'service-events': return `Service (${item.serviceId || 'Unknown'})`;
        case 'part-events':
        case 'partition-events': return `Partition (${item.partitionId || 'Unknown'})`;
        case 'rep-events':
        case 'replica-events': return `Replica (${item.replicaId || 'Unknown'})`;
        default: return 'Cluster';
    }
}
