/**
 * Metrics report generator.
 */

import * as vscode from 'vscode';
import { SfMgr } from '../../sfMgr';
import { SfUtility } from '../../sfUtility';
import {
    resolveClusterEndpoint,
    formatMetricTable,
    writeAndOpenReport,
} from './ReportUtils';

export async function generateMetricsReport(
    context: vscode.ExtensionContext,
    sfMgr: SfMgr,
    item: any,
): Promise<void> {
    if (!item || item.itemType !== 'metrics') {
        SfUtility.showWarning('This command is only available for Metrics');
        return;
    }
    const clusterEndpoint = resolveClusterEndpoint(item, sfMgr);
    if (!clusterEndpoint) { return; }

    await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Generating Metrics Report',
        cancellable: false,
    }, async (progress) => {
        progress.report({ increment: 10, message: 'Fetching cluster metrics...' });
        const sfRest = sfMgr.getCurrentSfConfig().getSfRest();
        const loadInfo = await sfRest.getClusterLoadInformation();

        progress.report({ increment: 40, message: 'Processing metrics data...' });
        progress.report({ increment: 30, message: 'Generating markdown...' });

        let markdown = `# Service Fabric Cluster Metrics Report\n\n`;
        markdown += `**Cluster:** \`${clusterEndpoint}\`  \n`;
        markdown += `**Generated:** ${new Date().toLocaleString()}  \n\n---\n\n`;

        if (loadInfo.lastBalancingStartTimeUtc || loadInfo.lastBalancingEndTimeUtc) {
            markdown += `## Last Resource Balancing\n\n`;
            if (loadInfo.lastBalancingStartTimeUtc) { markdown += `**Start Time:** ${new Date(loadInfo.lastBalancingStartTimeUtc).toLocaleString()}  \n`; }
            if (loadInfo.lastBalancingEndTimeUtc) {
                markdown += `**End Time:** ${new Date(loadInfo.lastBalancingEndTimeUtc).toLocaleString()}  \n`;
                if (loadInfo.lastBalancingStartTimeUtc) {
                    const dur = new Date(loadInfo.lastBalancingEndTimeUtc).getTime() - new Date(loadInfo.lastBalancingStartTimeUtc).getTime();
                    markdown += `**Duration:** ${dur}ms  \n`;
                }
            }
            markdown += `\n---\n\n`;
        }

        const metrics = loadInfo.loadMetricInformation;
        if (metrics && metrics.length > 0) {
            markdown += `## Load Metrics (${metrics.length} metrics)\n\n`;
            markdown += `| Metric | Cluster Load | Capacity | Usage % | Min Node | Max Node | Balanced |\n|--------|--------------|----------|---------|----------|----------|----------|\n`;

            metrics.forEach((m: any) => {
                const load = m.currentClusterLoad || m.clusterLoad || '0';
                const cap = m.clusterCapacity || 'N/A';
                const minN = m.minNodeLoadNodeId?.id || 'N/A';
                const maxN = m.maxNodeLoadNodeId?.id || 'N/A';
                const bal = m.isBalancedAfter !== undefined ? (m.isBalancedAfter ? '‚úÖ' : '‚ùå') : 'N/A';
                let pct = 'N/A';
                if (cap !== 'N/A' && cap !== '0') {
                    const c = parseFloat(cap), l = parseFloat(load);
                    if (!isNaN(c) && !isNaN(l) && c > 0) { pct = `${((l / c) * 100).toFixed(1)}%`; }
                }
                markdown += `| ${m.name || 'Unknown'} | ${load} | ${cap} | ${pct} | ${minN} | ${maxN} | ${bal} |\n`;
            });
            markdown += `\n## Detailed Metrics\n\n`;

            metrics.forEach((m: any) => {
                markdown += `### ${m.name || 'Unknown Metric'}\n\n`;
                if (m.isClusterCapacityViolation) { markdown += `> ‚ö†Ô∏è **WARNING:** This metric is currently over capacity!\n\n`; }
                markdown += formatMetricTable(m);
                markdown += `<details>\n<summary>üìã Full Metric JSON</summary>\n\n\`\`\`json\n${JSON.stringify(m, null, 2)}\n\`\`\`\n</details>\n\n---\n\n`;
            });
        } else {
            markdown += `## No Metrics Data\n\nNo load metric information is available for this cluster.\n`;
        }
        markdown += `\n---\n\n*Report generated by Service Fabric Diagnostic Extension*\n`;

        await writeAndOpenReport(context, clusterEndpoint, 'metrics-report', markdown, progress);
    });
}
